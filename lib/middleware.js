/*!
 * cofee-script - middleware (adapted from the less-middleware)
 *
 * Original Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

var jsx = require('react-tools'),
    fs = require('fs'),
    url = require('url'),
    path = require('path'),
    mkdirp = require('mkdirp');

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    `debug`           Output debugging information
 *    `force`           Always re-compile
 *    `once`            Only re-compile the one time
 *    `src`             Source directory used to find .jsx files
 *
 * Examples:
 *
 * Pass the middleware to Connect, grabbing .jsx files from this directory
 * and saving .js files to _./public_. Also supplying our custom `compile` function.
 *
 * Following that we have a `static` layer setup to serve the .js
 * files generated by JSXTransformer.
 *
 *      var server = connect.createServer(
 *          coffee.middleware({
 *              src: __dirname + '/public'
 *          })
 *        , connect.static(__dirname + '/public')
 *      );
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */
module.exports = jsx.middleware = function(options){
  var regex = {
    handle: /\.js$/
  };

  options = options || {};

  // Accept src/dest dir
  if ('string' === typeof options) {
    options = { src: options };
  }

  // Only log if in debug mode
  var log = function(key, val, type) {
    if(options.debug || type === 'error') {
      switch(type) {
        case 'log':
        case 'info':
        case 'error':
        case 'warn':
          break;
        default:
          type = 'log';
      }

      console[type]('  \033[90m%s :\033[0m \033[36m%s\033[0m', key, val);
    }
  };

  var coffeeError = function(err) {
    log("JSX " + err.name, err.message, 'error');
  };

  // Once option
  options.once = options.once || false;

  // Source dir required
  var src = options.src;
  if (!src) { throw new Error('jsx.middleware() requires "src" directory'); }

  // Middleware
  return function(req, res, next) {
    if ('GET' != req.method.toUpperCase() && 'HEAD' != req.method.toUpperCase()) { return next(); }

    var pathname = url.parse(req.url).pathname;

    // Only handle the matching files
    if (regex.handle.test(pathname)) {
      if (options.prefix && 0 === pathname.indexOf(options.prefix)) {
        pathname = pathname.substring(options.prefix.length);
      }

      var jsxPath = path.join(src, pathname.replace('.js', '.jsx'));

      log('source', jsxPath);

      // Ignore ENOENT to fall through as 404
      var error = function(err) {
        return next('ENOENT' == err.code ? null : err);
      };

      // Compile coffee
      var compile = function() {
        log('read', jsxPath);

        fs.readFile(jsxPath, 'utf8', function(err, str){
          if (err) { return error(err); }

          try {
            // Compile the jsx to js
            log('render', jsxPath);
            compiledJs = jsx.transform(str);

            // Specify the type as JS and send back content
            res.type('js');
            res.send(compiledJs);
          } catch (err) {
            coffeeError(err);
            return next(err);
          }
        });
      };

      // Force
      if (options.force) { return compile(); }

      // Only check/recompile if it has not been done at before
      if (options.once) { return next(); }

      // Compile the files
      return compile();
    } else {
      return next();
    }
  };
};
